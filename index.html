<!DOCTYPE html>
<html lang="en">
    <head>
    <title>Test</title>
    <!-- Meta tags -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Welcome to My portfolio and CV presented in an innovative terminal UI. Explore my skills, experience, and projects.">
    <!-- Stylesheets -->
    <link rel="stylesheet" href="https://unpkg.com/xterm@5.2.1/css/xterm.css">
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono&display=swap" rel="stylesheet">
    <style>
        *,
        *::before,
        *::after {
        box-sizing: border-box;
        padding: 0;
        margin: 0;
        }

        #terminal {
        height: 100%;
        }

        #terminal .xterm-screen {
        height: 100% !important;
        max-width: 100%;
        overflow-y: auto;
        }

        #terminal .xterm-viewport {
        background-color: transparent !important;
        }

        /* Generated Dynamic CSS Code */
        
    #terminal {
      background: url('') center/cover no-repeat fixed;
      position: fixed;
      inset: 0;
    }
    .xterm-screen {
      width:911px!important;
      background: rgba(22, 33, 62, 0.5);
      backdrop-filter: blur(9px);
      padding: 15px 15px 15px 15px;
      border: 1px solid #00ff00;
      border-radius: 12px;
      box-shadow: 0px 0px 10px #021a32;
      max-height: calc(100vh - 94px);
    }
    .terminal {
      padding: 50px 40px 12px 100px;
    }
    .xterm-rows {
      text-shadow: 0px 0px 0px #00ff00;
    }
    
    </style>
    <!-- JavaScript Libraries -->
    <script src="https://unpkg.com/xterm@5.2.1/lib/xterm.js"></script>
    <script src="https://unpkg.com/xterm-addon-fit@0.7.0/lib/xterm-addon-fit.js"></script>
    <script src="https://unpkg.com/xterm-addon-web-links@0.8.0/lib/xterm-addon-web-links.js"></script>
    </head>
    <body>
    <!-- Terminal UI -->
    <div id="terminal"></div>

    <script>
        // CV Terminal Class - Start
        class CVTerminal {
        terminal;
        isAnimating;
        command;
        addons;
        addonsConfig;
        prompt;
        promptLength;
        cursorX;
        printingFullCV;
        interrupted;
        commands;
        cvSections;
        cv;
        currentSectionIndex;
        animationFrameId;

        constructor(config) {
            this.config = config;
            this.initializeProperties();
            this.installAddons();
            this.openTerminal(this.config.container);
            this.fitTerminal();
            this.registerEvents();
            this.writeWelcomeMessage();
        }

        fitTerminal() {
            const fitAddon = this.addons["FitAddon"];
            fitAddon && fitAddon.fit();
        }

        openTerminal(container) {
            this.terminal.open(container);
            this.terminal.focus();
        }

        writeWelcomeMessage() {
            this.terminal.writeln("Welcome to My CV!");
            this.terminal.writeln("Type 'help' to see available commands.");
            this.writePrompt();
        }

        initializeProperties() {
            this.terminal = new Terminal(this.config.terminal);
            this.isAnimating = false;
            this.command = "";
            this.addons = {};
            this.addonsConfig = this.config.addons;
            this.prompt = this.config.cv.prompt;
            this.promptLength = this.prompt.length;
            this.cursorX = this.promptLength;
            this.printingFullCV = false;
            this.interrupted = false;
            this.commands = new Set(this.config.cv.commands);
            this.cvSections = new Set(this.config.cv.cvSections);
            this.cv = this.config.cv.cv;
            this.currentSectionIndex = 0;
            this.animationFrameId = -1;
        }

        installAddons() {
            this.addons = {};
            for (const addon of this.addonsConfig) {
            const addonConstructor = Object.values(addon.instance)[0];
            const addonInstance = new addonConstructor();
            this.addons[addon.instance.name] = addonInstance;
            this.terminal.loadAddon(addonInstance);
            if (addon.autoFit) {
                addonInstance.fit();
            }
            }
        }

        registerEvents() {
            this.terminal.onKey((event) => this.handleKeyEvent(event));
            window.addEventListener("resize", () => this.fitTerminal());

            document.addEventListener("click", (event) => {
            const isTerminalClick = event.composedPath().some((el) => el === this.terminal.element);
            if (isTerminalClick) {
                this.terminal.focus();
            } else if (!isTerminalClick) {
                this.terminal.blur();
            }
            });
        }

        handleKeyEvent({ key, domEvent }) {
            const isCtrlC = domEvent.ctrlKey && domEvent.key.toLowerCase() === "c";
            const isPrintable = !domEvent.altKey && !domEvent.ctrlKey && !domEvent.metaKey;

            const KEYCODE = {
            Backspace: "Backspace",
            Enter: "Enter",
            ArrowUp: "ArrowUp",
            ArrowDown: "ArrowDown",
            ArrowLeft: "ArrowLeft",
            ArrowRight: "ArrowRight",
            };

            if (this.isAnimating && isCtrlC) {
            return this.interruptAnimation();
            }
            if (this.isAnimating) return;

            switch (domEvent.key) {
            case KEYCODE.Backspace:
                this.handleBackspace();
                break;
            case KEYCODE.Enter:
                this.handleReturn();
                break;
            case KEYCODE.ArrowUp:
            case KEYCODE.ArrowDown:
            case KEYCODE.ArrowLeft:
            case KEYCODE.ArrowRight:
                break;
            default:
                if (isPrintable) {
                this.handleInput(key);
                }
            }
        }

        stopAnimation() {
            this.interrupted = false;
            this.isAnimating = false;
            cancelAnimationFrame(this.animationFrameId);
            this.resetFullCV();
        }

        handleBackspace() {
            if (this.cursorX > this.promptLength) {
            this.terminal.write("\b \b");
            this.cursorX--;
            }
        }

        handleReturn() {
            this.terminal.writeln("");
            this.handleCommand();
            this.command = "";
            this.cursorX = this.promptLength;
            if (!this.isAnimating) {
            this.writePrompt();
            }
        }

        handleInput(key) {
            this.terminal.write(key);
            this.command += key;
            this.cursorX++;
        }

        writePrompt() {
            this.terminal.write(this.prompt);
        }

        handleCommand() {
            const trimmedCommand = this.command.trim();

            if (this.commands.has(trimmedCommand)) {
            switch (trimmedCommand) {
                case "help":
                this.writeHelp();
                break;
                case "fullcv":
                this.startFullCV();
                break;
                default:
                this.writeSection(trimmedCommand);
            }
            } else {
            this.terminal.writeln("ðŸ’¡  Command not recognized: " + trimmedCommand + "!");
            this.terminal.writeln("Type 'help' to see available commands.");
            }
        }

        writeHelp() {
            let helpText = "\n  AVAILABLE COMMANDS:\n\n";
            for (const cmd of this.commands) {
            helpText += "- " + cmd + "\n";
            }

            this.isAnimating = true;
            this.animateTyping(helpText, 0, () => {
            this.isAnimating = false;
            this.writePrompt();
            });
        }

        startFullCV() {
            this.printingFullCV = true;
            this.handleFullCVCommand();
        }

        writeSection(sectionName) {
            const section = "\n  " + sectionName.toUpperCase();
            this.terminal.writeln(section);
            const commandInfo = "\r\n" + this.cv[sectionName].join('\n');

            if (this.interrupted) return;

            this.isAnimating = true;
            this.animateTyping(commandInfo, 0, () => {
            this.isAnimating = false;
            if (this.printingFullCV) {
                this.handleFullCVCommand();
            } else {
                this.writePrompt();
            }
            });
        }

        handleFullCVCommand() {
            const cvSectionsArray = Array.from(this.cvSections);

            if (this.currentSectionIndex >= cvSectionsArray.length) {
            this.resetFullCV();
            this.writePrompt();
            } else {
            this.printingFullCV = true;
            const command = cvSectionsArray[this.currentSectionIndex];
            this.currentSectionIndex++;
            this.writeSection(command);
            }
        }

        resetFullCV() {
            this.currentSectionIndex = 0;
            this.printingFullCV = false;
        }

        animateTyping(text, pos, callback) {
            if (this.interrupted) {
            return this.stopAnimation();
            }

            if (pos < text.length) {
            this.terminal.write(text.charAt(pos));
            if (text.charAt(pos) === "\n") {
                this.terminal.write("\r");
            }
            this.animationFrameId = requestAnimationFrame(() =>
                this.animateTyping(text, pos + 1, callback)
            );
            } else {
            this.terminal.writeln("\r");
            this.isAnimating = false;
            callback && callback();
            }
        }

        interruptAnimation() {
            this.stopAnimation();
            this.terminal.write("\r\n\nInterrupted\r\n\n");
            this.writePrompt();
        }
    }

// Initialize the terminal 
window.onload = () => {
     
  const addonsConfig = [
    { instance: FitAddon, autoFit: true },
    { instance: WebLinksAddon },
  ];

  const terminalSettings = {
  "fontSize": 12,
  "fontFamily": "'JetBrains Mono', monospace",
  "cursorStyle": "block",
  "cursorBlink": true,
  "theme": {
    "background": "#16213e",
    "foreground": "#00ff00",
    "cursor": "#00ff00"
  },
  "cols": 120,
  "rows": 32
};

const cvInteraction = {
  "commands": [
    "help",
    "about",
    "experience",
    "projects",
    "education",
    "licenses",
    "contact"
  ],
  "cvSections": [
    "about",
    "experience",
    "projects",
    "education",
    "licenses",
    "contact"
  ],
  "cv": {
    "about": [
      "Zane Pearton, Software Engineer specializing in DevOps at Accenture. " +
      "Passionate about machine learning, natural language processing, and " +
      "developing innovative software solutions."
    ],
    "experience": [
      "Software Engineer - DevOps @ Accenture: Involved in various projects " +
      "focused on automating and optimizing development workflows and " +
      "infrastructure management."
    ],
    "projects": [
      "Langchaingpt: A Python library for NLP and text processing.",
      "McDeepNet: Machine Learning model for analyzing McDonald's reviews.",
      "G-Net: TensorFlow implementation of GANs for image generation.",
      "neuroSnake: A ML-powered Snake game.",
      "MSGR-ChatApp: A chat application using React and Firebase."
    ],
    "education": [
      "(Your educational background details)"
    ],
    "licenses": [
      "Microsoft Certified: Azure Data Scientist Associate - Feb 2023",
      "Microsoft Certified: Azure AI Engineer Associate - Dec 2022",
      "Microsoft Certified: Azure Data Engineer Associate - Dec 2022",
      "Microsoft Certified: Security, Compliance, and Identity Fundamentals - Dec 2022",
      "Microsoft Certified: Azure AI Fundamentals - Nov 2022",
      "Microsoft Certified: Azure Data Fundamentals - Nov 2022",
      "Microsoft Certified: Azure Fundamentals - Oct 2022",
      "Amazon Web Services Cloud Practitioner - Jan 2022",
      "Programming Essentials in Python - Python Software Foundation - Jan 2021",
      "Security Analyst - Skillsoft (Credential ID 27306224) - Jan 2021",
      "COBOL Programming with VSCode - IBM - Dec 2020",
      "Introduction to Cybersecurity - Cisco - Dec 2020",
      "NDG Linux Essentials - Cisco"
    ],
    "contact": [
      "LinkedIn: Zane Pearton",
      "GitHub: Zane Pearton",
      "Personal Website: zanepearton.com"
    ]
  },
  "prompt": "root > "
};


  const terminalConfigurations = {
    terminal: terminalSettings,
    cv: cvInteraction,
    addons: addonsConfig,
    container: document.querySelector("#terminal"),
    };
  
    new CVTerminal(terminalConfigurations);
}
    </script>
    </body>
</html>
  
